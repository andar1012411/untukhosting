import { jsx as a, jsxs as Q, Fragment as Ie } from "react/jsx-runtime";
import * as n from "react";
import { r as _e } from "../../index-B7Vxkz5-.js";
import { a as Ne, u as Te, c as N } from "../../index-WxTJUbsU.js";
import { u as lt, c as it } from "../../index-BOS8297p.js";
import { u as V, S as ct } from "../../index-nyDQUcyF.js";
import { c as dt, P as M, a as G, u as ut } from "../../index-CDSAOBSC.js";
import { c as Ee, R as pt, A as ft, P as mt, D as ht, C as vt, a as gt } from "../../index-Uwi29ejC.js";
import { h as St, u as wt, R as xt, F as yt, C as Ct } from "../../check-Cr0B_rVR.js";
import { V as bt } from "../../index-C_tBg_Tl.js";
import { c as j } from "../../utils-B9KdtH6G.js";
import { C as Me } from "../../chevron-down-C5iFRv8a.js";
import { c as It } from "../../createLucideIcon-DUBSZsqM.js";
function Re(e, [o, t]) {
  return Math.min(t, Math.max(o, e));
}
function Tt(e) {
  const o = n.useRef({ value: e, previous: e });
  return n.useMemo(() => (o.current.value !== e && (o.current.previous = o.current.value, o.current.value = e), o.current.previous), [e]);
}
var Pt = [" ", "Enter", "ArrowUp", "ArrowDown"], Nt = [" ", "Enter"], ae = "Select", [de, ue, Rt] = it(ae), [oe, Co] = dt(ae, [
  Rt,
  Ee
]), pe = Ee(), [_t, Y] = oe(ae), [Et, Mt] = oe(ae), Ae = (e) => {
  const {
    __scopeSelect: o,
    children: t,
    open: i,
    defaultOpen: c,
    onOpenChange: p,
    value: s,
    defaultValue: l,
    onValueChange: r,
    dir: f,
    name: g,
    autoComplete: x,
    disabled: T,
    required: P,
    form: I
  } = e, d = pe(o), [v, y] = n.useState(null), [u, h] = n.useState(null), [A, O] = n.useState(!1), ne = lt(f), [R = !1, k] = Ne({
    prop: i,
    defaultProp: c,
    onChange: p
  }), [z, X] = Ne({
    prop: s,
    defaultProp: l,
    onChange: r
  }), B = n.useRef(null), H = v ? I || !!v.closest("form") : !0, [K, F] = n.useState(/* @__PURE__ */ new Set()), U = Array.from(K).map((_) => _.props.value).join(";");
  return /* @__PURE__ */ a(pt, { ...d, children: /* @__PURE__ */ Q(
    _t,
    {
      required: P,
      scope: o,
      trigger: v,
      onTriggerChange: y,
      valueNode: u,
      onValueNodeChange: h,
      valueNodeHasChildren: A,
      onValueNodeHasChildrenChange: O,
      contentId: Te(),
      value: z,
      onValueChange: X,
      open: R,
      onOpenChange: k,
      dir: ne,
      triggerPointerDownPosRef: B,
      disabled: T,
      children: [
        /* @__PURE__ */ a(de.Provider, { scope: o, children: /* @__PURE__ */ a(
          Et,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: n.useCallback((_) => {
              F((L) => new Set(L).add(_));
            }, []),
            onNativeOptionRemove: n.useCallback((_) => {
              F((L) => {
                const W = new Set(L);
                return W.delete(_), W;
              });
            }, []),
            children: t
          }
        ) }),
        H ? /* @__PURE__ */ Q(
          rt,
          {
            "aria-hidden": !0,
            required: P,
            tabIndex: -1,
            name: g,
            autoComplete: x,
            value: z,
            onChange: (_) => X(_.target.value),
            disabled: T,
            form: I,
            children: [
              z === void 0 ? /* @__PURE__ */ a("option", { value: "" }) : null,
              Array.from(K)
            ]
          },
          U
        ) : null
      ]
    }
  ) });
};
Ae.displayName = ae;
var Oe = "SelectTrigger", De = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, disabled: i = !1, ...c } = e, p = pe(t), s = Y(Oe, t), l = s.disabled || i, r = V(o, s.onTriggerChange), f = ue(t), g = n.useRef("touch"), [x, T, P] = st((d) => {
      const v = f().filter((h) => !h.disabled), y = v.find((h) => h.value === s.value), u = at(v, d, y);
      u !== void 0 && s.onValueChange(u.value);
    }), I = (d) => {
      l || (s.onOpenChange(!0), P()), d && (s.triggerPointerDownPosRef.current = {
        x: Math.round(d.pageX),
        y: Math.round(d.pageY)
      });
    };
    return /* @__PURE__ */ a(ft, { asChild: !0, ...p, children: /* @__PURE__ */ a(
      M.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": s.contentId,
        "aria-expanded": s.open,
        "aria-required": s.required,
        "aria-autocomplete": "none",
        dir: s.dir,
        "data-state": s.open ? "open" : "closed",
        disabled: l,
        "data-disabled": l ? "" : void 0,
        "data-placeholder": nt(s.value) ? "" : void 0,
        ...c,
        ref: r,
        onClick: N(c.onClick, (d) => {
          d.currentTarget.focus(), g.current !== "mouse" && I(d);
        }),
        onPointerDown: N(c.onPointerDown, (d) => {
          g.current = d.pointerType;
          const v = d.target;
          v.hasPointerCapture(d.pointerId) && v.releasePointerCapture(d.pointerId), d.button === 0 && d.ctrlKey === !1 && d.pointerType === "mouse" && (I(d), d.preventDefault());
        }),
        onKeyDown: N(c.onKeyDown, (d) => {
          const v = x.current !== "";
          !(d.ctrlKey || d.altKey || d.metaKey) && d.key.length === 1 && T(d.key), !(v && d.key === " ") && Pt.includes(d.key) && (I(), d.preventDefault());
        })
      }
    ) });
  }
);
De.displayName = Oe;
var ke = "SelectValue", Le = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, className: i, style: c, children: p, placeholder: s = "", ...l } = e, r = Y(ke, t), { onValueNodeHasChildrenChange: f } = r, g = p !== void 0, x = V(o, r.onValueNodeChange);
    return G(() => {
      f(g);
    }, [f, g]), /* @__PURE__ */ a(
      M.span,
      {
        ...l,
        ref: x,
        style: { pointerEvents: "none" },
        children: nt(r.value) ? /* @__PURE__ */ a(Ie, { children: s }) : p
      }
    );
  }
);
Le.displayName = ke;
var At = "SelectIcon", Ve = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, children: i, ...c } = e;
    return /* @__PURE__ */ a(M.span, { "aria-hidden": !0, ...c, ref: o, children: i || "â–¼" });
  }
);
Ve.displayName = At;
var Ot = "SelectPortal", Be = (e) => /* @__PURE__ */ a(mt, { asChild: !0, ...e });
Be.displayName = Ot;
var ee = "SelectContent", He = n.forwardRef(
  (e, o) => {
    const t = Y(ee, e.__scopeSelect), [i, c] = n.useState();
    if (G(() => {
      c(new DocumentFragment());
    }, []), !t.open) {
      const p = i;
      return p ? _e.createPortal(
        /* @__PURE__ */ a(Fe, { scope: e.__scopeSelect, children: /* @__PURE__ */ a(de.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ a("div", { children: e.children }) }) }),
        p
      ) : null;
    }
    return /* @__PURE__ */ a(Ue, { ...e, ref: o });
  }
);
He.displayName = ee;
var D = 10, [Fe, q] = oe(ee), Dt = "SelectContentImpl", Ue = n.forwardRef(
  (e, o) => {
    const {
      __scopeSelect: t,
      position: i = "item-aligned",
      onCloseAutoFocus: c,
      onEscapeKeyDown: p,
      onPointerDownOutside: s,
      //
      // PopperContent props
      side: l,
      sideOffset: r,
      align: f,
      alignOffset: g,
      arrowPadding: x,
      collisionBoundary: T,
      collisionPadding: P,
      sticky: I,
      hideWhenDetached: d,
      avoidCollisions: v,
      //
      ...y
    } = e, u = Y(ee, t), [h, A] = n.useState(null), [O, ne] = n.useState(null), R = V(o, (m) => A(m)), [k, z] = n.useState(null), [X, B] = n.useState(
      null
    ), H = ue(t), [K, F] = n.useState(!1), U = n.useRef(!1);
    n.useEffect(() => {
      if (h) return St(h);
    }, [h]), wt();
    const _ = n.useCallback(
      (m) => {
        const [b, ...E] = H().map((w) => w.ref.current), [C] = E.slice(-1), S = document.activeElement;
        for (const w of m)
          if (w === S || (w == null || w.scrollIntoView({ block: "nearest" }), w === b && O && (O.scrollTop = 0), w === C && O && (O.scrollTop = O.scrollHeight), w == null || w.focus(), document.activeElement !== S)) return;
      },
      [H, O]
    ), L = n.useCallback(
      () => _([k, h]),
      [_, k, h]
    );
    n.useEffect(() => {
      K && L();
    }, [K, L]);
    const { onOpenChange: W, triggerPointerDownPosRef: $ } = u;
    n.useEffect(() => {
      if (h) {
        let m = { x: 0, y: 0 };
        const b = (C) => {
          var S, w;
          m = {
            x: Math.abs(Math.round(C.pageX) - (((S = $.current) == null ? void 0 : S.x) ?? 0)),
            y: Math.abs(Math.round(C.pageY) - (((w = $.current) == null ? void 0 : w.y) ?? 0))
          };
        }, E = (C) => {
          m.x <= 10 && m.y <= 10 ? C.preventDefault() : h.contains(C.target) || W(!1), document.removeEventListener("pointermove", b), $.current = null;
        };
        return $.current !== null && (document.addEventListener("pointermove", b), document.addEventListener("pointerup", E, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", b), document.removeEventListener("pointerup", E, { capture: !0 });
        };
      }
    }, [h, W, $]), n.useEffect(() => {
      const m = () => W(!1);
      return window.addEventListener("blur", m), window.addEventListener("resize", m), () => {
        window.removeEventListener("blur", m), window.removeEventListener("resize", m);
      };
    }, [W]);
    const [fe, le] = st((m) => {
      const b = H().filter((S) => !S.disabled), E = b.find((S) => S.ref.current === document.activeElement), C = at(b, m, E);
      C && setTimeout(() => C.ref.current.focus());
    }), me = n.useCallback(
      (m, b, E) => {
        const C = !U.current && !E;
        (u.value !== void 0 && u.value === b || C) && (z(m), C && (U.current = !0));
      },
      [u.value]
    ), he = n.useCallback(() => h == null ? void 0 : h.focus(), [h]), te = n.useCallback(
      (m, b, E) => {
        const C = !U.current && !E;
        (u.value !== void 0 && u.value === b || C) && B(m);
      },
      [u.value]
    ), ie = i === "popper" ? we : We, re = ie === we ? {
      side: l,
      sideOffset: r,
      align: f,
      alignOffset: g,
      arrowPadding: x,
      collisionBoundary: T,
      collisionPadding: P,
      sticky: I,
      hideWhenDetached: d,
      avoidCollisions: v
    } : {};
    return /* @__PURE__ */ a(
      Fe,
      {
        scope: t,
        content: h,
        viewport: O,
        onViewportChange: ne,
        itemRefCallback: me,
        selectedItem: k,
        onItemLeave: he,
        itemTextRefCallback: te,
        focusSelectedItem: L,
        selectedItemText: X,
        position: i,
        isPositioned: K,
        searchRef: fe,
        children: /* @__PURE__ */ a(xt, { as: ct, allowPinchZoom: !0, children: /* @__PURE__ */ a(
          yt,
          {
            asChild: !0,
            trapped: u.open,
            onMountAutoFocus: (m) => {
              m.preventDefault();
            },
            onUnmountAutoFocus: N(c, (m) => {
              var b;
              (b = u.trigger) == null || b.focus({ preventScroll: !0 }), m.preventDefault();
            }),
            children: /* @__PURE__ */ a(
              ht,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: p,
                onPointerDownOutside: s,
                onFocusOutside: (m) => m.preventDefault(),
                onDismiss: () => u.onOpenChange(!1),
                children: /* @__PURE__ */ a(
                  ie,
                  {
                    role: "listbox",
                    id: u.contentId,
                    "data-state": u.open ? "open" : "closed",
                    dir: u.dir,
                    onContextMenu: (m) => m.preventDefault(),
                    ...y,
                    ...re,
                    onPlaced: () => F(!0),
                    ref: R,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...y.style
                    },
                    onKeyDown: N(y.onKeyDown, (m) => {
                      const b = m.ctrlKey || m.altKey || m.metaKey;
                      if (m.key === "Tab" && m.preventDefault(), !b && m.key.length === 1 && le(m.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(m.key)) {
                        let C = H().filter((S) => !S.disabled).map((S) => S.ref.current);
                        if (["ArrowUp", "End"].includes(m.key) && (C = C.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(m.key)) {
                          const S = m.target, w = C.indexOf(S);
                          C = C.slice(w + 1);
                        }
                        setTimeout(() => _(C)), m.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
Ue.displayName = Dt;
var kt = "SelectItemAlignedPosition", We = n.forwardRef((e, o) => {
  const { __scopeSelect: t, onPlaced: i, ...c } = e, p = Y(ee, t), s = q(ee, t), [l, r] = n.useState(null), [f, g] = n.useState(null), x = V(o, (R) => g(R)), T = ue(t), P = n.useRef(!1), I = n.useRef(!0), { viewport: d, selectedItem: v, selectedItemText: y, focusSelectedItem: u } = s, h = n.useCallback(() => {
    if (p.trigger && p.valueNode && l && f && d && v && y) {
      const R = p.trigger.getBoundingClientRect(), k = f.getBoundingClientRect(), z = p.valueNode.getBoundingClientRect(), X = y.getBoundingClientRect();
      if (p.dir !== "rtl") {
        const S = X.left - k.left, w = z.left - S, Z = R.left - w, J = R.width + Z, ve = Math.max(J, k.width), ge = window.innerWidth - D, Se = Re(w, [
          D,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(D, ge - ve)
        ]);
        l.style.minWidth = J + "px", l.style.left = Se + "px";
      } else {
        const S = k.right - X.right, w = window.innerWidth - z.right - S, Z = window.innerWidth - R.right - w, J = R.width + Z, ve = Math.max(J, k.width), ge = window.innerWidth - D, Se = Re(w, [
          D,
          Math.max(D, ge - ve)
        ]);
        l.style.minWidth = J + "px", l.style.right = Se + "px";
      }
      const B = T(), H = window.innerHeight - D * 2, K = d.scrollHeight, F = window.getComputedStyle(f), U = parseInt(F.borderTopWidth, 10), _ = parseInt(F.paddingTop, 10), L = parseInt(F.borderBottomWidth, 10), W = parseInt(F.paddingBottom, 10), $ = U + _ + K + W + L, fe = Math.min(v.offsetHeight * 5, $), le = window.getComputedStyle(d), me = parseInt(le.paddingTop, 10), he = parseInt(le.paddingBottom, 10), te = R.top + R.height / 2 - D, ie = H - te, re = v.offsetHeight / 2, m = v.offsetTop + re, b = U + _ + m, E = $ - b;
      if (b <= te) {
        const S = B.length > 0 && v === B[B.length - 1].ref.current;
        l.style.bottom = "0px";
        const w = f.clientHeight - d.offsetTop - d.offsetHeight, Z = Math.max(
          ie,
          re + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (S ? he : 0) + w + L
        ), J = b + Z;
        l.style.height = J + "px";
      } else {
        const S = B.length > 0 && v === B[0].ref.current;
        l.style.top = "0px";
        const Z = Math.max(
          te,
          U + d.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (S ? me : 0) + re
        ) + E;
        l.style.height = Z + "px", d.scrollTop = b - te + d.offsetTop;
      }
      l.style.margin = `${D}px 0`, l.style.minHeight = fe + "px", l.style.maxHeight = H + "px", i == null || i(), requestAnimationFrame(() => P.current = !0);
    }
  }, [
    T,
    p.trigger,
    p.valueNode,
    l,
    f,
    d,
    v,
    y,
    p.dir,
    i
  ]);
  G(() => h(), [h]);
  const [A, O] = n.useState();
  G(() => {
    f && O(window.getComputedStyle(f).zIndex);
  }, [f]);
  const ne = n.useCallback(
    (R) => {
      R && I.current === !0 && (h(), u == null || u(), I.current = !1);
    },
    [h, u]
  );
  return /* @__PURE__ */ a(
    Vt,
    {
      scope: t,
      contentWrapper: l,
      shouldExpandOnScrollRef: P,
      onScrollButtonChange: ne,
      children: /* @__PURE__ */ a(
        "div",
        {
          ref: r,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: A
          },
          children: /* @__PURE__ */ a(
            M.div,
            {
              ...c,
              ref: x,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...c.style
              }
            }
          )
        }
      )
    }
  );
});
We.displayName = kt;
var Lt = "SelectPopperPosition", we = n.forwardRef((e, o) => {
  const {
    __scopeSelect: t,
    align: i = "start",
    collisionPadding: c = D,
    ...p
  } = e, s = pe(t);
  return /* @__PURE__ */ a(
    vt,
    {
      ...s,
      ...p,
      ref: o,
      align: i,
      collisionPadding: c,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...p.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
we.displayName = Lt;
var [Vt, Pe] = oe(ee, {}), xe = "SelectViewport", ze = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, nonce: i, ...c } = e, p = q(xe, t), s = Pe(xe, t), l = V(o, p.onViewportChange), r = n.useRef(0);
    return /* @__PURE__ */ Q(Ie, { children: [
      /* @__PURE__ */ a(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: i
        }
      ),
      /* @__PURE__ */ a(de.Slot, { scope: t, children: /* @__PURE__ */ a(
        M.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...c,
          ref: l,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...c.style
          },
          onScroll: N(c.onScroll, (f) => {
            const g = f.currentTarget, { contentWrapper: x, shouldExpandOnScrollRef: T } = s;
            if (T != null && T.current && x) {
              const P = Math.abs(r.current - g.scrollTop);
              if (P > 0) {
                const I = window.innerHeight - D * 2, d = parseFloat(x.style.minHeight), v = parseFloat(x.style.height), y = Math.max(d, v);
                if (y < I) {
                  const u = y + P, h = Math.min(I, u), A = u - h;
                  x.style.height = h + "px", x.style.bottom === "0px" && (g.scrollTop = A > 0 ? A : 0, x.style.justifyContent = "flex-end");
                }
              }
            }
            r.current = g.scrollTop;
          })
        }
      ) })
    ] });
  }
);
ze.displayName = xe;
var Ke = "SelectGroup", [Bt, Ht] = oe(Ke), $e = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, ...i } = e, c = Te();
    return /* @__PURE__ */ a(Bt, { scope: t, id: c, children: /* @__PURE__ */ a(M.div, { role: "group", "aria-labelledby": c, ...i, ref: o }) });
  }
);
$e.displayName = Ke;
var Ge = "SelectLabel", je = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, ...i } = e, c = Ht(Ge, t);
    return /* @__PURE__ */ a(M.div, { id: c.id, ...i, ref: o });
  }
);
je.displayName = Ge;
var ce = "SelectItem", [Ft, Ye] = oe(ce), qe = n.forwardRef(
  (e, o) => {
    const {
      __scopeSelect: t,
      value: i,
      disabled: c = !1,
      textValue: p,
      ...s
    } = e, l = Y(ce, t), r = q(ce, t), f = l.value === i, [g, x] = n.useState(p ?? ""), [T, P] = n.useState(!1), I = V(
      o,
      (u) => {
        var h;
        return (h = r.itemRefCallback) == null ? void 0 : h.call(r, u, i, c);
      }
    ), d = Te(), v = n.useRef("touch"), y = () => {
      c || (l.onValueChange(i), l.onOpenChange(!1));
    };
    if (i === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ a(
      Ft,
      {
        scope: t,
        value: i,
        disabled: c,
        textId: d,
        isSelected: f,
        onItemTextChange: n.useCallback((u) => {
          x((h) => h || ((u == null ? void 0 : u.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ a(
          de.ItemSlot,
          {
            scope: t,
            value: i,
            disabled: c,
            textValue: g,
            children: /* @__PURE__ */ a(
              M.div,
              {
                role: "option",
                "aria-labelledby": d,
                "data-highlighted": T ? "" : void 0,
                "aria-selected": f && T,
                "data-state": f ? "checked" : "unchecked",
                "aria-disabled": c || void 0,
                "data-disabled": c ? "" : void 0,
                tabIndex: c ? void 0 : -1,
                ...s,
                ref: I,
                onFocus: N(s.onFocus, () => P(!0)),
                onBlur: N(s.onBlur, () => P(!1)),
                onClick: N(s.onClick, () => {
                  v.current !== "mouse" && y();
                }),
                onPointerUp: N(s.onPointerUp, () => {
                  v.current === "mouse" && y();
                }),
                onPointerDown: N(s.onPointerDown, (u) => {
                  v.current = u.pointerType;
                }),
                onPointerMove: N(s.onPointerMove, (u) => {
                  var h;
                  v.current = u.pointerType, c ? (h = r.onItemLeave) == null || h.call(r) : v.current === "mouse" && u.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: N(s.onPointerLeave, (u) => {
                  var h;
                  u.currentTarget === document.activeElement && ((h = r.onItemLeave) == null || h.call(r));
                }),
                onKeyDown: N(s.onKeyDown, (u) => {
                  var A;
                  ((A = r.searchRef) == null ? void 0 : A.current) !== "" && u.key === " " || (Nt.includes(u.key) && y(), u.key === " " && u.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
qe.displayName = ce;
var se = "SelectItemText", Xe = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, className: i, style: c, ...p } = e, s = Y(se, t), l = q(se, t), r = Ye(se, t), f = Mt(se, t), [g, x] = n.useState(null), T = V(
      o,
      (y) => x(y),
      r.onItemTextChange,
      (y) => {
        var u;
        return (u = l.itemTextRefCallback) == null ? void 0 : u.call(l, y, r.value, r.disabled);
      }
    ), P = g == null ? void 0 : g.textContent, I = n.useMemo(
      () => /* @__PURE__ */ a("option", { value: r.value, disabled: r.disabled, children: P }, r.value),
      [r.disabled, r.value, P]
    ), { onNativeOptionAdd: d, onNativeOptionRemove: v } = f;
    return G(() => (d(I), () => v(I)), [d, v, I]), /* @__PURE__ */ Q(Ie, { children: [
      /* @__PURE__ */ a(M.span, { id: r.textId, ...p, ref: T }),
      r.isSelected && s.valueNode && !s.valueNodeHasChildren ? _e.createPortal(p.children, s.valueNode) : null
    ] });
  }
);
Xe.displayName = se;
var Ze = "SelectItemIndicator", Je = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, ...i } = e;
    return Ye(Ze, t).isSelected ? /* @__PURE__ */ a(M.span, { "aria-hidden": !0, ...i, ref: o }) : null;
  }
);
Je.displayName = Ze;
var ye = "SelectScrollUpButton", Qe = n.forwardRef((e, o) => {
  const t = q(ye, e.__scopeSelect), i = Pe(ye, e.__scopeSelect), [c, p] = n.useState(!1), s = V(o, i.onScrollButtonChange);
  return G(() => {
    if (t.viewport && t.isPositioned) {
      let l = function() {
        const f = r.scrollTop > 0;
        p(f);
      };
      const r = t.viewport;
      return l(), r.addEventListener("scroll", l), () => r.removeEventListener("scroll", l);
    }
  }, [t.viewport, t.isPositioned]), c ? /* @__PURE__ */ a(
    tt,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: l, selectedItem: r } = t;
        l && r && (l.scrollTop = l.scrollTop - r.offsetHeight);
      }
    }
  ) : null;
});
Qe.displayName = ye;
var Ce = "SelectScrollDownButton", et = n.forwardRef((e, o) => {
  const t = q(Ce, e.__scopeSelect), i = Pe(Ce, e.__scopeSelect), [c, p] = n.useState(!1), s = V(o, i.onScrollButtonChange);
  return G(() => {
    if (t.viewport && t.isPositioned) {
      let l = function() {
        const f = r.scrollHeight - r.clientHeight, g = Math.ceil(r.scrollTop) < f;
        p(g);
      };
      const r = t.viewport;
      return l(), r.addEventListener("scroll", l), () => r.removeEventListener("scroll", l);
    }
  }, [t.viewport, t.isPositioned]), c ? /* @__PURE__ */ a(
    tt,
    {
      ...e,
      ref: s,
      onAutoScroll: () => {
        const { viewport: l, selectedItem: r } = t;
        l && r && (l.scrollTop = l.scrollTop + r.offsetHeight);
      }
    }
  ) : null;
});
et.displayName = Ce;
var tt = n.forwardRef((e, o) => {
  const { __scopeSelect: t, onAutoScroll: i, ...c } = e, p = q("SelectScrollButton", t), s = n.useRef(null), l = ue(t), r = n.useCallback(() => {
    s.current !== null && (window.clearInterval(s.current), s.current = null);
  }, []);
  return n.useEffect(() => () => r(), [r]), G(() => {
    var g;
    const f = l().find((x) => x.ref.current === document.activeElement);
    (g = f == null ? void 0 : f.ref.current) == null || g.scrollIntoView({ block: "nearest" });
  }, [l]), /* @__PURE__ */ a(
    M.div,
    {
      "aria-hidden": !0,
      ...c,
      ref: o,
      style: { flexShrink: 0, ...c.style },
      onPointerDown: N(c.onPointerDown, () => {
        s.current === null && (s.current = window.setInterval(i, 50));
      }),
      onPointerMove: N(c.onPointerMove, () => {
        var f;
        (f = p.onItemLeave) == null || f.call(p), s.current === null && (s.current = window.setInterval(i, 50));
      }),
      onPointerLeave: N(c.onPointerLeave, () => {
        r();
      })
    }
  );
}), Ut = "SelectSeparator", ot = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, ...i } = e;
    return /* @__PURE__ */ a(M.div, { "aria-hidden": !0, ...i, ref: o });
  }
);
ot.displayName = Ut;
var be = "SelectArrow", Wt = n.forwardRef(
  (e, o) => {
    const { __scopeSelect: t, ...i } = e, c = pe(t), p = Y(be, t), s = q(be, t);
    return p.open && s.position === "popper" ? /* @__PURE__ */ a(gt, { ...c, ...i, ref: o }) : null;
  }
);
Wt.displayName = be;
function nt(e) {
  return e === "" || e === void 0;
}
var rt = n.forwardRef(
  (e, o) => {
    const { value: t, ...i } = e, c = n.useRef(null), p = V(o, c), s = Tt(t);
    return n.useEffect(() => {
      const l = c.current, r = window.HTMLSelectElement.prototype, g = Object.getOwnPropertyDescriptor(
        r,
        "value"
      ).set;
      if (s !== t && g) {
        const x = new Event("change", { bubbles: !0 });
        g.call(l, t), l.dispatchEvent(x);
      }
    }, [s, t]), /* @__PURE__ */ a(bt, { asChild: !0, children: /* @__PURE__ */ a("select", { ...i, ref: p, defaultValue: t }) });
  }
);
rt.displayName = "BubbleSelect";
function st(e) {
  const o = ut(e), t = n.useRef(""), i = n.useRef(0), c = n.useCallback(
    (s) => {
      const l = t.current + s;
      o(l), function r(f) {
        t.current = f, window.clearTimeout(i.current), f !== "" && (i.current = window.setTimeout(() => r(""), 1e3));
      }(l);
    },
    [o]
  ), p = n.useCallback(() => {
    t.current = "", window.clearTimeout(i.current);
  }, []);
  return n.useEffect(() => () => window.clearTimeout(i.current), []), [t, c, p];
}
function at(e, o, t) {
  const c = o.length > 1 && Array.from(o).every((f) => f === o[0]) ? o[0] : o, p = t ? e.indexOf(t) : -1;
  let s = zt(e, Math.max(p, 0));
  c.length === 1 && (s = s.filter((f) => f !== t));
  const r = s.find(
    (f) => f.textValue.toLowerCase().startsWith(c.toLowerCase())
  );
  return r !== t ? r : void 0;
}
function zt(e, o) {
  return e.map((t, i) => e[(o + i) % e.length]);
}
var Kt = Ae, $t = De, Gt = Le, jt = Ve, Yt = Be, qt = He, Xt = ze, Zt = $e, Jt = je, Qt = qe, eo = Xe, to = Je, oo = Qe, no = et, ro = ot;
/**
 * @license lucide-react v0.483.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const so = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], ao = It("ChevronUp", so);
function bo({
  ...e
}) {
  return /* @__PURE__ */ a(Kt, { "data-slot": "select", ...e });
}
function Io({
  ...e
}) {
  return /* @__PURE__ */ a(Zt, { "data-slot": "select-group", ...e });
}
function To({
  ...e
}) {
  return /* @__PURE__ */ a(Gt, { "data-slot": "select-value", ...e });
}
function Po({
  className: e,
  size: o = "default",
  children: t,
  ...i
}) {
  return /* @__PURE__ */ Q(
    $t,
    {
      "data-slot": "select-trigger",
      "data-size": o,
      className: j(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        e
      ),
      ...i,
      children: [
        t,
        /* @__PURE__ */ a(jt, { asChild: !0, children: /* @__PURE__ */ a(Me, { className: "size-4 opacity-50" }) })
      ]
    }
  );
}
function No({
  className: e,
  children: o,
  position: t = "popper",
  ...i
}) {
  return /* @__PURE__ */ a(Yt, { children: /* @__PURE__ */ Q(
    qt,
    {
      "data-slot": "select-content",
      className: j(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md",
        t === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        e
      ),
      position: t,
      ...i,
      children: [
        /* @__PURE__ */ a(lo, {}),
        /* @__PURE__ */ a(
          Xt,
          {
            className: j(
              "p-1",
              t === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
            ),
            children: o
          }
        ),
        /* @__PURE__ */ a(io, {})
      ]
    }
  ) });
}
function Ro({
  className: e,
  ...o
}) {
  return /* @__PURE__ */ a(
    Jt,
    {
      "data-slot": "select-label",
      className: j("text-muted-foreground px-2 py-1.5 text-xs", e),
      ...o
    }
  );
}
function _o({
  className: e,
  children: o,
  ...t
}) {
  return /* @__PURE__ */ Q(
    Qt,
    {
      "data-slot": "select-item",
      className: j(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        e
      ),
      ...t,
      children: [
        /* @__PURE__ */ a("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: /* @__PURE__ */ a(to, { children: /* @__PURE__ */ a(Ct, { className: "size-4" }) }) }),
        /* @__PURE__ */ a(eo, { children: o })
      ]
    }
  );
}
function Eo({
  className: e,
  ...o
}) {
  return /* @__PURE__ */ a(
    ro,
    {
      "data-slot": "select-separator",
      className: j("bg-border pointer-events-none -mx-1 my-1 h-px", e),
      ...o
    }
  );
}
function lo({
  className: e,
  ...o
}) {
  return /* @__PURE__ */ a(
    oo,
    {
      "data-slot": "select-scroll-up-button",
      className: j(
        "flex cursor-default items-center justify-center py-1",
        e
      ),
      ...o,
      children: /* @__PURE__ */ a(ao, { className: "size-4" })
    }
  );
}
function io({
  className: e,
  ...o
}) {
  return /* @__PURE__ */ a(
    no,
    {
      "data-slot": "select-scroll-down-button",
      className: j(
        "flex cursor-default items-center justify-center py-1",
        e
      ),
      ...o,
      children: /* @__PURE__ */ a(Me, { className: "size-4" })
    }
  );
}
export {
  bo as Select,
  No as SelectContent,
  Io as SelectGroup,
  _o as SelectItem,
  Ro as SelectLabel,
  io as SelectScrollDownButton,
  lo as SelectScrollUpButton,
  Eo as SelectSeparator,
  Po as SelectTrigger,
  To as SelectValue
};
