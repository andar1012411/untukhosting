import { useState as c, useEffect as R, useCallback as u, useMemo as I } from "react";
import { useDebounce as J } from "./useDebounce.js";
function ct({
  initialData: d = [],
  filterFields: Q = [],
  onDataFetch: p,
  onServerFilter: w,
  onServerSort: b,
  onServerSearch: T,
  defaultPageSize: W = 10,
  isServerSide: s = !1,
  sortable: E = !0,
  rowKey: D = "id",
  keyboardNavigation: j = !0
}) {
  const [k, z] = c(d), [l, B] = c({}), [F, O] = c(""), [a, G] = c(null), [f, x] = c(1), [r, X] = c(W), [Y, y] = c(0), [Z, P] = c(0), [_, A] = c(!1), [$, K] = c([]), [N, H] = c(null), [m, h] = c(null), C = J(F, 300), v = J(l, 300);
  R(() => {
    f !== 1 && x(1);
  }, [v, C]);
  const U = u(async () => {
    if (s) {
      A(!0), H(null);
      try {
        if (p) {
          const { items: t, totalCount: n, totalPages: e } = await p(f, r);
          z(t), y(n), P(e);
        }
      } catch (t) {
        console.error("Error fetching data:", t), H(t instanceof Error ? t : new Error("Failed to fetch data"));
      } finally {
        A(!1);
      }
    }
  }, [f, r, p, s]);
  R(() => {
    s ? U() : (z(d), y(d.length), P(Math.ceil(d.length / r)));
  }, [s, d, U, r]);
  const S = u(
    (t, n) => {
      B((e) => {
        const o = { ...e };
        return n === "all" || n === "" ? delete o[t] : o[t] = n, o;
      }), s && w && w(
        Object.entries(l).map(([e, o]) => ({
          field: e,
          value: o
        }))
      );
    },
    [l, s, w]
  ), tt = u(
    (t) => {
      E && (G((n) => {
        const e = (n == null ? void 0 : n.field) === t && n.direction === "asc" ? "desc" : "asc";
        return { field: t, direction: e };
      }), s && b && b({
        field: t,
        direction: (a == null ? void 0 : a.field) === t && a.direction === "asc" ? "desc" : "asc"
      }));
    },
    [a, E, s, b]
  ), nt = u(
    (t) => {
      O(t), s && T && T(t);
    },
    [s, T]
  ), L = u((t) => {
    K((n) => n.includes(t) ? n.filter((e) => e !== t) : [...n, t]);
  }, []), et = u(() => {
    B({}), O(""), G(null), x(1);
  }, []), M = I(() => s ? k : k.filter((t) => {
    for (const n in l) {
      const e = t[n];
      if (l[n] !== "all" && !String(e).includes(l[n]))
        return !1;
    }
    if (C) {
      const n = C.toLowerCase();
      return Object.keys(t).some((e) => {
        const o = t[e];
        return o == null ? !1 : String(o).toLowerCase().includes(n);
      });
    }
    return !0;
  }), [k, l, C, s]), i = I(() => s || !a ? M : [...M].sort((t, n) => {
    const e = t[a.field], o = n[a.field];
    if (e == null) return 1;
    if (o == null) return -1;
    if (typeof e == "string" && typeof o == "string")
      return a.direction === "asc" ? e.localeCompare(o) : o.localeCompare(e);
    if (typeof e == "number" && typeof o == "number")
      return a.direction === "asc" ? e - o : o - e;
    if (e instanceof Date && o instanceof Date)
      return a.direction === "asc" ? e.getTime() - o.getTime() : o.getTime() - e.getTime();
    const V = String(e), q = String(o);
    return a.direction === "asc" ? V.localeCompare(q) : q.localeCompare(V);
  }), [M, a, s]), g = I(() => {
    if (s) return i;
    const t = (f - 1) * r, n = t + r;
    return i.slice(t, n);
  }, [i, f, r, s]);
  R(() => {
    s || (y(i.length), P(Math.ceil(i.length / r) || 1));
  }, [i, r, s]);
  const ot = u(
    (t) => {
      if (!(!j || g.length === 0))
        switch (t.key) {
          case "ArrowDown":
            t.preventDefault(), h((n) => n === null ? 0 : Math.min(n + 1, g.length - 1));
            break;
          case "ArrowUp":
            t.preventDefault(), h((n) => n === null ? 0 : Math.max(n - 1, 0));
            break;
          case "Home":
            t.preventDefault(), h(0);
            break;
          case "End":
            t.preventDefault(), h(g.length - 1);
            break;
          case "Enter":
            if (m !== null) {
              const n = g[m];
              n && L(String(n[D]));
            }
            break;
        }
    },
    [j, g, m, L, D]
  );
  return {
    data: g,
    filters: l,
    filterFields: Q,
    searchTerm: F,
    sortConfig: a,
    sortable: E,
    rowKey: D,
    currentPage: f,
    pageSize: r,
    totalCount: Y,
    totalPages: Z,
    isLoading: _,
    error: N,
    expandedRows: $,
    activeRowIndex: m,
    setIsLoading: A,
    handleFilterChange: S,
    handleSortChange: tt,
    handleSearchChange: nt,
    setCurrentPage: x,
    setPageSize: X,
    toggleExpand: L,
    resetFilters: et,
    setActiveRowIndex: h,
    handleKeyDown: ot
  };
}
export {
  ct as useTailGrid
};
