import * as y from "react";
import { useLayoutEffect as Te, useEffect as Me } from "react";
import { c as bt } from "./index-WxTJUbsU.js";
import { u as gt, P as tt, d as ke, a as ut, c as Ne } from "./index-CDSAOBSC.js";
import { u as wt } from "./index-nyDQUcyF.js";
import { jsx as H } from "react/jsx-runtime";
import { r as Fe, R as We } from "./index-B7Vxkz5-.js";
function Be(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = gt(t);
  y.useEffect(() => {
    const o = (r) => {
      r.key === "Escape" && n(r);
    };
    return e.addEventListener("keydown", o, { capture: !0 }), () => e.removeEventListener("keydown", o, { capture: !0 });
  }, [n, e]);
}
var $e = "DismissableLayer", Pt = "dismissableLayer.update", He = "dismissableLayer.pointerDownOutside", _e = "dismissableLayer.focusOutside", Yt, te = y.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), ze = y.forwardRef(
  (t, e) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: o,
      onPointerDownOutside: r,
      onFocusOutside: i,
      onInteractOutside: s,
      onDismiss: c,
      ...a
    } = t, l = y.useContext(te), [f, u] = y.useState(null), p = (f == null ? void 0 : f.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, d] = y.useState({}), h = wt(e, (x) => u(x)), m = Array.from(l.layers), [w] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), g = m.indexOf(w), v = f ? m.indexOf(f) : -1, E = l.layersWithOutsidePointerEventsDisabled.size > 0, b = v >= g, A = Ye((x) => {
      const O = x.target, M = [...l.branches].some((C) => C.contains(O));
      !b || M || (r == null || r(x), s == null || s(x), x.defaultPrevented || c == null || c());
    }, p), P = je((x) => {
      const O = x.target;
      [...l.branches].some((C) => C.contains(O)) || (i == null || i(x), s == null || s(x), x.defaultPrevented || c == null || c());
    }, p);
    return Be((x) => {
      v === l.layers.size - 1 && (o == null || o(x), !x.defaultPrevented && c && (x.preventDefault(), c()));
    }, p), y.useEffect(() => {
      if (f)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (Yt = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(f)), l.layers.add(f), jt(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = Yt);
        };
    }, [f, p, n, l]), y.useEffect(() => () => {
      f && (l.layers.delete(f), l.layersWithOutsidePointerEventsDisabled.delete(f), jt());
    }, [f, l]), y.useEffect(() => {
      const x = () => d({});
      return document.addEventListener(Pt, x), () => document.removeEventListener(Pt, x);
    }, []), /* @__PURE__ */ H(
      tt.div,
      {
        ...a,
        ref: h,
        style: {
          pointerEvents: E ? b ? "auto" : "none" : void 0,
          ...t.style
        },
        onFocusCapture: bt(t.onFocusCapture, P.onFocusCapture),
        onBlurCapture: bt(t.onBlurCapture, P.onBlurCapture),
        onPointerDownCapture: bt(
          t.onPointerDownCapture,
          A.onPointerDownCapture
        )
      }
    );
  }
);
ze.displayName = $e;
var Ie = "DismissableLayerBranch", Ve = y.forwardRef((t, e) => {
  const n = y.useContext(te), o = y.useRef(null), r = wt(e, o);
  return y.useEffect(() => {
    const i = o.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ H(tt.div, { ...t, ref: r });
});
Ve.displayName = Ie;
function Ye(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = gt(t), o = y.useRef(!1), r = y.useRef(() => {
  });
  return y.useEffect(() => {
    const i = (c) => {
      if (c.target && !o.current) {
        let a = function() {
          ee(
            He,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: c };
        c.pointerType === "touch" ? (e.removeEventListener("click", r.current), r.current = a, e.addEventListener("click", r.current, { once: !0 })) : a();
      } else
        e.removeEventListener("click", r.current);
      o.current = !1;
    }, s = window.setTimeout(() => {
      e.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(s), e.removeEventListener("pointerdown", i), e.removeEventListener("click", r.current);
    };
  }, [e, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => o.current = !0
  };
}
function je(t, e = globalThis == null ? void 0 : globalThis.document) {
  const n = gt(t), o = y.useRef(!1);
  return y.useEffect(() => {
    const r = (i) => {
      i.target && !o.current && ee(_e, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", r), () => e.removeEventListener("focusin", r);
  }, [e, n]), {
    onFocusCapture: () => o.current = !0,
    onBlurCapture: () => o.current = !1
  };
}
function jt() {
  const t = new CustomEvent(Pt);
  document.dispatchEvent(t);
}
function ee(t, e, n, { discrete: o }) {
  const r = n.originalEvent.target, i = new CustomEvent(t, { bubbles: !1, cancelable: !0, detail: n });
  e && r.addEventListener(t, e, { once: !0 }), o ? ke(r, i) : r.dispatchEvent(i);
}
const Xe = ["top", "right", "bottom", "left"], q = Math.min, W = Math.max, dt = Math.round, at = Math.floor, V = (t) => ({
  x: t,
  y: t
}), Ue = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, qe = {
  start: "end",
  end: "start"
};
function Rt(t, e, n) {
  return W(t, q(e, n));
}
function X(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function U(t) {
  return t.split("-")[0];
}
function et(t) {
  return t.split("-")[1];
}
function St(t) {
  return t === "x" ? "y" : "x";
}
function Dt(t) {
  return t === "y" ? "height" : "width";
}
function K(t) {
  return ["top", "bottom"].includes(U(t)) ? "y" : "x";
}
function Lt(t) {
  return St(K(t));
}
function Ke(t, e, n) {
  n === void 0 && (n = !1);
  const o = et(t), r = Lt(t), i = Dt(r);
  let s = r === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return e.reference[i] > e.floating[i] && (s = pt(s)), [s, pt(s)];
}
function Ze(t) {
  const e = pt(t);
  return [Ot(t), e, Ot(e)];
}
function Ot(t) {
  return t.replace(/start|end/g, (e) => qe[e]);
}
function Ge(t, e, n) {
  const o = ["left", "right"], r = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (t) {
    case "top":
    case "bottom":
      return n ? e ? r : o : e ? o : r;
    case "left":
    case "right":
      return e ? i : s;
    default:
      return [];
  }
}
function Je(t, e, n, o) {
  const r = et(t);
  let i = Ge(U(t), n === "start", o);
  return r && (i = i.map((s) => s + "-" + r), e && (i = i.concat(i.map(Ot)))), i;
}
function pt(t) {
  return t.replace(/left|right|bottom|top/g, (e) => Ue[e]);
}
function Qe(t) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...t
  };
}
function ne(t) {
  return typeof t != "number" ? Qe(t) : {
    top: t,
    right: t,
    bottom: t,
    left: t
  };
}
function ht(t) {
  const {
    x: e,
    y: n,
    width: o,
    height: r
  } = t;
  return {
    width: o,
    height: r,
    top: n,
    left: e,
    right: e + o,
    bottom: n + r,
    x: e,
    y: n
  };
}
function Xt(t, e, n) {
  let {
    reference: o,
    floating: r
  } = t;
  const i = K(e), s = Lt(e), c = Dt(s), a = U(e), l = i === "y", f = o.x + o.width / 2 - r.width / 2, u = o.y + o.height / 2 - r.height / 2, p = o[c] / 2 - r[c] / 2;
  let d;
  switch (a) {
    case "top":
      d = {
        x: f,
        y: o.y - r.height
      };
      break;
    case "bottom":
      d = {
        x: f,
        y: o.y + o.height
      };
      break;
    case "right":
      d = {
        x: o.x + o.width,
        y: u
      };
      break;
    case "left":
      d = {
        x: o.x - r.width,
        y: u
      };
      break;
    default:
      d = {
        x: o.x,
        y: o.y
      };
  }
  switch (et(e)) {
    case "start":
      d[s] -= p * (n && l ? -1 : 1);
      break;
    case "end":
      d[s] += p * (n && l ? -1 : 1);
      break;
  }
  return d;
}
const tn = async (t, e, n) => {
  const {
    placement: o = "bottom",
    strategy: r = "absolute",
    middleware: i = [],
    platform: s
  } = n, c = i.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(e));
  let l = await s.getElementRects({
    reference: t,
    floating: e,
    strategy: r
  }), {
    x: f,
    y: u
  } = Xt(l, o, a), p = o, d = {}, h = 0;
  for (let m = 0; m < c.length; m++) {
    const {
      name: w,
      fn: g
    } = c[m], {
      x: v,
      y: E,
      data: b,
      reset: A
    } = await g({
      x: f,
      y: u,
      initialPlacement: o,
      placement: p,
      strategy: r,
      middlewareData: d,
      rects: l,
      platform: s,
      elements: {
        reference: t,
        floating: e
      }
    });
    f = v ?? f, u = E ?? u, d = {
      ...d,
      [w]: {
        ...d[w],
        ...b
      }
    }, A && h <= 50 && (h++, typeof A == "object" && (A.placement && (p = A.placement), A.rects && (l = A.rects === !0 ? await s.getElementRects({
      reference: t,
      floating: e,
      strategy: r
    }) : A.rects), {
      x: f,
      y: u
    } = Xt(l, p, a)), m = -1);
  }
  return {
    x: f,
    y: u,
    placement: p,
    strategy: r,
    middlewareData: d
  };
};
async function rt(t, e) {
  var n;
  e === void 0 && (e = {});
  const {
    x: o,
    y: r,
    platform: i,
    rects: s,
    elements: c,
    strategy: a
  } = t, {
    boundary: l = "clippingAncestors",
    rootBoundary: f = "viewport",
    elementContext: u = "floating",
    altBoundary: p = !1,
    padding: d = 0
  } = X(e, t), h = ne(d), w = c[p ? u === "floating" ? "reference" : "floating" : u], g = ht(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(w))) == null || n ? w : w.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(c.floating)),
    boundary: l,
    rootBoundary: f,
    strategy: a
  })), v = u === "floating" ? {
    x: o,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, E = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c.floating)), b = await (i.isElement == null ? void 0 : i.isElement(E)) ? await (i.getScale == null ? void 0 : i.getScale(E)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, A = ht(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: v,
    offsetParent: E,
    strategy: a
  }) : v);
  return {
    top: (g.top - A.top + h.top) / b.y,
    bottom: (A.bottom - g.bottom + h.bottom) / b.y,
    left: (g.left - A.left + h.left) / b.x,
    right: (A.right - g.right + h.right) / b.x
  };
}
const en = (t) => ({
  name: "arrow",
  options: t,
  async fn(e) {
    const {
      x: n,
      y: o,
      placement: r,
      rects: i,
      platform: s,
      elements: c,
      middlewareData: a
    } = e, {
      element: l,
      padding: f = 0
    } = X(t, e) || {};
    if (l == null)
      return {};
    const u = ne(f), p = {
      x: n,
      y: o
    }, d = Lt(r), h = Dt(d), m = await s.getDimensions(l), w = d === "y", g = w ? "top" : "left", v = w ? "bottom" : "right", E = w ? "clientHeight" : "clientWidth", b = i.reference[h] + i.reference[d] - p[d] - i.floating[h], A = p[d] - i.reference[d], P = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l));
    let x = P ? P[E] : 0;
    (!x || !await (s.isElement == null ? void 0 : s.isElement(P))) && (x = c.floating[E] || i.floating[h]);
    const O = b / 2 - A / 2, M = x / 2 - m[h] / 2 - 1, C = q(u[g], M), N = q(u[v], M), F = C, D = x - m[h] - N, S = x / 2 - m[h] / 2 + O, $ = Rt(F, S, D), L = !a.arrow && et(r) != null && S !== $ && i.reference[h] / 2 - (S < F ? C : N) - m[h] / 2 < 0, T = L ? S < F ? S - F : S - D : 0;
    return {
      [d]: p[d] + T,
      data: {
        [d]: $,
        centerOffset: S - $ - T,
        ...L && {
          alignmentOffset: T
        }
      },
      reset: L
    };
  }
}), nn = function(t) {
  return t === void 0 && (t = {}), {
    name: "flip",
    options: t,
    async fn(e) {
      var n, o;
      const {
        placement: r,
        middlewareData: i,
        rects: s,
        initialPlacement: c,
        platform: a,
        elements: l
      } = e, {
        mainAxis: f = !0,
        crossAxis: u = !0,
        fallbackPlacements: p,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: h = "none",
        flipAlignment: m = !0,
        ...w
      } = X(t, e);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const g = U(r), v = K(c), E = U(c) === c, b = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), A = p || (E || !m ? [pt(c)] : Ze(c)), P = h !== "none";
      !p && P && A.push(...Je(c, m, h, b));
      const x = [c, ...A], O = await rt(e, w), M = [];
      let C = ((o = i.flip) == null ? void 0 : o.overflows) || [];
      if (f && M.push(O[g]), u) {
        const S = Ke(r, s, b);
        M.push(O[S[0]], O[S[1]]);
      }
      if (C = [...C, {
        placement: r,
        overflows: M
      }], !M.every((S) => S <= 0)) {
        var N, F;
        const S = (((N = i.flip) == null ? void 0 : N.index) || 0) + 1, $ = x[S];
        if ($)
          return {
            data: {
              index: S,
              overflows: C
            },
            reset: {
              placement: $
            }
          };
        let L = (F = C.filter((T) => T.overflows[0] <= 0).sort((T, R) => T.overflows[1] - R.overflows[1])[0]) == null ? void 0 : F.placement;
        if (!L)
          switch (d) {
            case "bestFit": {
              var D;
              const T = (D = C.filter((R) => {
                if (P) {
                  const k = K(R.placement);
                  return k === v || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  k === "y";
                }
                return !0;
              }).map((R) => [R.placement, R.overflows.filter((k) => k > 0).reduce((k, I) => k + I, 0)]).sort((R, k) => R[1] - k[1])[0]) == null ? void 0 : D[0];
              T && (L = T);
              break;
            }
            case "initialPlacement":
              L = c;
              break;
          }
        if (r !== L)
          return {
            reset: {
              placement: L
            }
          };
      }
      return {};
    }
  };
};
function Ut(t, e) {
  return {
    top: t.top - e.height,
    right: t.right - e.width,
    bottom: t.bottom - e.height,
    left: t.left - e.width
  };
}
function qt(t) {
  return Xe.some((e) => t[e] >= 0);
}
const on = function(t) {
  return t === void 0 && (t = {}), {
    name: "hide",
    options: t,
    async fn(e) {
      const {
        rects: n
      } = e, {
        strategy: o = "referenceHidden",
        ...r
      } = X(t, e);
      switch (o) {
        case "referenceHidden": {
          const i = await rt(e, {
            ...r,
            elementContext: "reference"
          }), s = Ut(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: qt(s)
            }
          };
        }
        case "escaped": {
          const i = await rt(e, {
            ...r,
            altBoundary: !0
          }), s = Ut(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: qt(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function rn(t, e) {
  const {
    placement: n,
    platform: o,
    elements: r
  } = t, i = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), s = U(n), c = et(n), a = K(n) === "y", l = ["left", "top"].includes(s) ? -1 : 1, f = i && a ? -1 : 1, u = X(e, t);
  let {
    mainAxis: p,
    crossAxis: d,
    alignmentAxis: h
  } = typeof u == "number" ? {
    mainAxis: u,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: u.mainAxis || 0,
    crossAxis: u.crossAxis || 0,
    alignmentAxis: u.alignmentAxis
  };
  return c && typeof h == "number" && (d = c === "end" ? h * -1 : h), a ? {
    x: d * f,
    y: p * l
  } : {
    x: p * l,
    y: d * f
  };
}
const sn = function(t) {
  return t === void 0 && (t = 0), {
    name: "offset",
    options: t,
    async fn(e) {
      var n, o;
      const {
        x: r,
        y: i,
        placement: s,
        middlewareData: c
      } = e, a = await rn(e, t);
      return s === ((n = c.offset) == null ? void 0 : n.placement) && (o = c.arrow) != null && o.alignmentOffset ? {} : {
        x: r + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: s
        }
      };
    }
  };
}, cn = function(t) {
  return t === void 0 && (t = {}), {
    name: "shift",
    options: t,
    async fn(e) {
      const {
        x: n,
        y: o,
        placement: r
      } = e, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: c = {
          fn: (w) => {
            let {
              x: g,
              y: v
            } = w;
            return {
              x: g,
              y: v
            };
          }
        },
        ...a
      } = X(t, e), l = {
        x: n,
        y: o
      }, f = await rt(e, a), u = K(U(r)), p = St(u);
      let d = l[p], h = l[u];
      if (i) {
        const w = p === "y" ? "top" : "left", g = p === "y" ? "bottom" : "right", v = d + f[w], E = d - f[g];
        d = Rt(v, d, E);
      }
      if (s) {
        const w = u === "y" ? "top" : "left", g = u === "y" ? "bottom" : "right", v = h + f[w], E = h - f[g];
        h = Rt(v, h, E);
      }
      const m = c.fn({
        ...e,
        [p]: d,
        [u]: h
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - o,
          enabled: {
            [p]: i,
            [u]: s
          }
        }
      };
    }
  };
}, ln = function(t) {
  return t === void 0 && (t = {}), {
    options: t,
    fn(e) {
      const {
        x: n,
        y: o,
        placement: r,
        rects: i,
        middlewareData: s
      } = e, {
        offset: c = 0,
        mainAxis: a = !0,
        crossAxis: l = !0
      } = X(t, e), f = {
        x: n,
        y: o
      }, u = K(r), p = St(u);
      let d = f[p], h = f[u];
      const m = X(c, e), w = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (a) {
        const E = p === "y" ? "height" : "width", b = i.reference[p] - i.floating[E] + w.mainAxis, A = i.reference[p] + i.reference[E] - w.mainAxis;
        d < b ? d = b : d > A && (d = A);
      }
      if (l) {
        var g, v;
        const E = p === "y" ? "width" : "height", b = ["top", "left"].includes(U(r)), A = i.reference[u] - i.floating[E] + (b && ((g = s.offset) == null ? void 0 : g[u]) || 0) + (b ? 0 : w.crossAxis), P = i.reference[u] + i.reference[E] + (b ? 0 : ((v = s.offset) == null ? void 0 : v[u]) || 0) - (b ? w.crossAxis : 0);
        h < A ? h = A : h > P && (h = P);
      }
      return {
        [p]: d,
        [u]: h
      };
    }
  };
}, an = function(t) {
  return t === void 0 && (t = {}), {
    name: "size",
    options: t,
    async fn(e) {
      var n, o;
      const {
        placement: r,
        rects: i,
        platform: s,
        elements: c
      } = e, {
        apply: a = () => {
        },
        ...l
      } = X(t, e), f = await rt(e, l), u = U(r), p = et(r), d = K(r) === "y", {
        width: h,
        height: m
      } = i.floating;
      let w, g;
      u === "top" || u === "bottom" ? (w = u, g = p === (await (s.isRTL == null ? void 0 : s.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (g = u, w = p === "end" ? "top" : "bottom");
      const v = m - f.top - f.bottom, E = h - f.left - f.right, b = q(m - f[w], v), A = q(h - f[g], E), P = !e.middlewareData.shift;
      let x = b, O = A;
      if ((n = e.middlewareData.shift) != null && n.enabled.x && (O = E), (o = e.middlewareData.shift) != null && o.enabled.y && (x = v), P && !p) {
        const C = W(f.left, 0), N = W(f.right, 0), F = W(f.top, 0), D = W(f.bottom, 0);
        d ? O = h - 2 * (C !== 0 || N !== 0 ? C + N : W(f.left, f.right)) : x = m - 2 * (F !== 0 || D !== 0 ? F + D : W(f.top, f.bottom));
      }
      await a({
        ...e,
        availableWidth: O,
        availableHeight: x
      });
      const M = await s.getDimensions(c.floating);
      return h !== M.width || m !== M.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function yt() {
  return typeof window < "u";
}
function nt(t) {
  return oe(t) ? (t.nodeName || "").toLowerCase() : "#document";
}
function B(t) {
  var e;
  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function j(t) {
  var e;
  return (e = (oe(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;
}
function oe(t) {
  return yt() ? t instanceof Node || t instanceof B(t).Node : !1;
}
function _(t) {
  return yt() ? t instanceof Element || t instanceof B(t).Element : !1;
}
function Y(t) {
  return yt() ? t instanceof HTMLElement || t instanceof B(t).HTMLElement : !1;
}
function Kt(t) {
  return !yt() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof B(t).ShadowRoot;
}
function st(t) {
  const {
    overflow: e,
    overflowX: n,
    overflowY: o,
    display: r
  } = z(t);
  return /auto|scroll|overlay|hidden|clip/.test(e + o + n) && !["inline", "contents"].includes(r);
}
function fn(t) {
  return ["table", "td", "th"].includes(nt(t));
}
function xt(t) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return t.matches(e);
    } catch {
      return !1;
    }
  });
}
function Tt(t) {
  const e = Mt(), n = _(t) ? z(t) : t;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !e && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function un(t) {
  let e = Z(t);
  for (; Y(e) && !Q(e); ) {
    if (Tt(e))
      return e;
    if (xt(e))
      return null;
    e = Z(e);
  }
  return null;
}
function Mt() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Q(t) {
  return ["html", "body", "#document"].includes(nt(t));
}
function z(t) {
  return B(t).getComputedStyle(t);
}
function vt(t) {
  return _(t) ? {
    scrollLeft: t.scrollLeft,
    scrollTop: t.scrollTop
  } : {
    scrollLeft: t.scrollX,
    scrollTop: t.scrollY
  };
}
function Z(t) {
  if (nt(t) === "html")
    return t;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    t.assignedSlot || // DOM Element detected.
    t.parentNode || // ShadowRoot detected.
    Kt(t) && t.host || // Fallback.
    j(t)
  );
  return Kt(e) ? e.host : e;
}
function re(t) {
  const e = Z(t);
  return Q(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Y(e) && st(e) ? e : re(e);
}
function it(t, e, n) {
  var o;
  e === void 0 && (e = []), n === void 0 && (n = !0);
  const r = re(t), i = r === ((o = t.ownerDocument) == null ? void 0 : o.body), s = B(r);
  if (i) {
    const c = Ct(s);
    return e.concat(s, s.visualViewport || [], st(r) ? r : [], c && n ? it(c) : []);
  }
  return e.concat(r, it(r, [], n));
}
function Ct(t) {
  return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null;
}
function ie(t) {
  const e = z(t);
  let n = parseFloat(e.width) || 0, o = parseFloat(e.height) || 0;
  const r = Y(t), i = r ? t.offsetWidth : n, s = r ? t.offsetHeight : o, c = dt(n) !== i || dt(o) !== s;
  return c && (n = i, o = s), {
    width: n,
    height: o,
    $: c
  };
}
function kt(t) {
  return _(t) ? t : t.contextElement;
}
function J(t) {
  const e = kt(t);
  if (!Y(e))
    return V(1);
  const n = e.getBoundingClientRect(), {
    width: o,
    height: r,
    $: i
  } = ie(e);
  let s = (i ? dt(n.width) : n.width) / o, c = (i ? dt(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const dn = /* @__PURE__ */ V(0);
function se(t) {
  const e = B(t);
  return !Mt() || !e.visualViewport ? dn : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function pn(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== B(t) ? !1 : e;
}
function G(t, e, n, o) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const r = t.getBoundingClientRect(), i = kt(t);
  let s = V(1);
  e && (o ? _(o) && (s = J(o)) : s = J(t));
  const c = pn(i, n, o) ? se(i) : V(0);
  let a = (r.left + c.x) / s.x, l = (r.top + c.y) / s.y, f = r.width / s.x, u = r.height / s.y;
  if (i) {
    const p = B(i), d = o && _(o) ? B(o) : o;
    let h = p, m = Ct(h);
    for (; m && o && d !== h; ) {
      const w = J(m), g = m.getBoundingClientRect(), v = z(m), E = g.left + (m.clientLeft + parseFloat(v.paddingLeft)) * w.x, b = g.top + (m.clientTop + parseFloat(v.paddingTop)) * w.y;
      a *= w.x, l *= w.y, f *= w.x, u *= w.y, a += E, l += b, h = B(m), m = Ct(h);
    }
  }
  return ht({
    width: f,
    height: u,
    x: a,
    y: l
  });
}
function Nt(t, e) {
  const n = vt(t).scrollLeft;
  return e ? e.left + n : G(j(t)).left + n;
}
function ce(t, e, n) {
  n === void 0 && (n = !1);
  const o = t.getBoundingClientRect(), r = o.left + e.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Nt(t, o)
  )), i = o.top + e.scrollTop;
  return {
    x: r,
    y: i
  };
}
function hn(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: o,
    strategy: r
  } = t;
  const i = r === "fixed", s = j(o), c = e ? xt(e.floating) : !1;
  if (o === s || c && i)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = V(1);
  const f = V(0), u = Y(o);
  if ((u || !u && !i) && ((nt(o) !== "body" || st(s)) && (a = vt(o)), Y(o))) {
    const d = G(o);
    l = J(o), f.x = d.x + o.clientLeft, f.y = d.y + o.clientTop;
  }
  const p = s && !u && !i ? ce(s, a, !0) : V(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - a.scrollLeft * l.x + f.x + p.x,
    y: n.y * l.y - a.scrollTop * l.y + f.y + p.y
  };
}
function mn(t) {
  return Array.from(t.getClientRects());
}
function gn(t) {
  const e = j(t), n = vt(t), o = t.ownerDocument.body, r = W(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth), i = W(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
  let s = -n.scrollLeft + Nt(t);
  const c = -n.scrollTop;
  return z(o).direction === "rtl" && (s += W(e.clientWidth, o.clientWidth) - r), {
    width: r,
    height: i,
    x: s,
    y: c
  };
}
function wn(t, e) {
  const n = B(t), o = j(t), r = n.visualViewport;
  let i = o.clientWidth, s = o.clientHeight, c = 0, a = 0;
  if (r) {
    i = r.width, s = r.height;
    const l = Mt();
    (!l || l && e === "fixed") && (c = r.offsetLeft, a = r.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: c,
    y: a
  };
}
function yn(t, e) {
  const n = G(t, !0, e === "fixed"), o = n.top + t.clientTop, r = n.left + t.clientLeft, i = Y(t) ? J(t) : V(1), s = t.clientWidth * i.x, c = t.clientHeight * i.y, a = r * i.x, l = o * i.y;
  return {
    width: s,
    height: c,
    x: a,
    y: l
  };
}
function Zt(t, e, n) {
  let o;
  if (e === "viewport")
    o = wn(t, n);
  else if (e === "document")
    o = gn(j(t));
  else if (_(e))
    o = yn(e, n);
  else {
    const r = se(t);
    o = {
      x: e.x - r.x,
      y: e.y - r.y,
      width: e.width,
      height: e.height
    };
  }
  return ht(o);
}
function le(t, e) {
  const n = Z(t);
  return n === e || !_(n) || Q(n) ? !1 : z(n).position === "fixed" || le(n, e);
}
function xn(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let o = it(t, [], !1).filter((c) => _(c) && nt(c) !== "body"), r = null;
  const i = z(t).position === "fixed";
  let s = i ? Z(t) : t;
  for (; _(s) && !Q(s); ) {
    const c = z(s), a = Tt(s);
    !a && c.position === "fixed" && (r = null), (i ? !a && !r : !a && c.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || st(s) && !a && le(t, s)) ? o = o.filter((f) => f !== s) : r = c, s = Z(s);
  }
  return e.set(t, o), o;
}
function vn(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: o,
    strategy: r
  } = t;
  const s = [...n === "clippingAncestors" ? xt(e) ? [] : xn(e, this._c) : [].concat(n), o], c = s[0], a = s.reduce((l, f) => {
    const u = Zt(e, f, r);
    return l.top = W(u.top, l.top), l.right = q(u.right, l.right), l.bottom = q(u.bottom, l.bottom), l.left = W(u.left, l.left), l;
  }, Zt(e, c, r));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function bn(t) {
  const {
    width: e,
    height: n
  } = ie(t);
  return {
    width: e,
    height: n
  };
}
function An(t, e, n) {
  const o = Y(e), r = j(e), i = n === "fixed", s = G(t, !0, i, e);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = V(0);
  if (o || !o && !i)
    if ((nt(e) !== "body" || st(r)) && (c = vt(e)), o) {
      const p = G(e, !0, i, e);
      a.x = p.x + e.clientLeft, a.y = p.y + e.clientTop;
    } else r && (a.x = Nt(r));
  const l = r && !o && !i ? ce(r, c) : V(0), f = s.left + c.scrollLeft - a.x - l.x, u = s.top + c.scrollTop - a.y - l.y;
  return {
    x: f,
    y: u,
    width: s.width,
    height: s.height
  };
}
function At(t) {
  return z(t).position === "static";
}
function Gt(t, e) {
  if (!Y(t) || z(t).position === "fixed")
    return null;
  if (e)
    return e(t);
  let n = t.offsetParent;
  return j(t) === n && (n = n.ownerDocument.body), n;
}
function ae(t, e) {
  const n = B(t);
  if (xt(t))
    return n;
  if (!Y(t)) {
    let r = Z(t);
    for (; r && !Q(r); ) {
      if (_(r) && !At(r))
        return r;
      r = Z(r);
    }
    return n;
  }
  let o = Gt(t, e);
  for (; o && fn(o) && At(o); )
    o = Gt(o, e);
  return o && Q(o) && At(o) && !Tt(o) ? n : o || un(t) || n;
}
const En = async function(t) {
  const e = this.getOffsetParent || ae, n = this.getDimensions, o = await n(t.floating);
  return {
    reference: An(t.reference, await e(t.floating), t.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function Pn(t) {
  return z(t).direction === "rtl";
}
const Rn = {
  convertOffsetParentRelativeRectToViewportRelativeRect: hn,
  getDocumentElement: j,
  getClippingRect: vn,
  getOffsetParent: ae,
  getElementRects: En,
  getClientRects: mn,
  getDimensions: bn,
  getScale: J,
  isElement: _,
  isRTL: Pn
};
function fe(t, e) {
  return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height;
}
function On(t, e) {
  let n = null, o;
  const r = j(t);
  function i() {
    var c;
    clearTimeout(o), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), i();
    const l = t.getBoundingClientRect(), {
      left: f,
      top: u,
      width: p,
      height: d
    } = l;
    if (c || e(), !p || !d)
      return;
    const h = at(u), m = at(r.clientWidth - (f + p)), w = at(r.clientHeight - (u + d)), g = at(f), E = {
      rootMargin: -h + "px " + -m + "px " + -w + "px " + -g + "px",
      threshold: W(0, q(1, a)) || 1
    };
    let b = !0;
    function A(P) {
      const x = P[0].intersectionRatio;
      if (x !== a) {
        if (!b)
          return s();
        x ? s(!1, x) : o = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      x === 1 && !fe(l, t.getBoundingClientRect()) && s(), b = !1;
    }
    try {
      n = new IntersectionObserver(A, {
        ...E,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(A, E);
    }
    n.observe(t);
  }
  return s(!0), i;
}
function Cn(t, e, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = o, l = kt(t), f = r || i ? [...l ? it(l) : [], ...it(e)] : [];
  f.forEach((g) => {
    r && g.addEventListener("scroll", n, {
      passive: !0
    }), i && g.addEventListener("resize", n);
  });
  const u = l && c ? On(l, n) : null;
  let p = -1, d = null;
  s && (d = new ResizeObserver((g) => {
    let [v] = g;
    v && v.target === l && d && (d.unobserve(e), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var E;
      (E = d) == null || E.observe(e);
    })), n();
  }), l && !a && d.observe(l), d.observe(e));
  let h, m = a ? G(t) : null;
  a && w();
  function w() {
    const g = G(t);
    m && !fe(m, g) && n(), m = g, h = requestAnimationFrame(w);
  }
  return n(), () => {
    var g;
    f.forEach((v) => {
      r && v.removeEventListener("scroll", n), i && v.removeEventListener("resize", n);
    }), u == null || u(), (g = d) == null || g.disconnect(), d = null, a && cancelAnimationFrame(h);
  };
}
const Sn = sn, Dn = cn, Ln = nn, Tn = an, Mn = on, Jt = en, kn = ln, Nn = (t, e, n) => {
  const o = /* @__PURE__ */ new Map(), r = {
    platform: Rn,
    ...n
  }, i = {
    ...r.platform,
    _c: o
  };
  return tn(t, e, {
    ...r,
    platform: i
  });
};
var ft = typeof document < "u" ? Te : Me;
function mt(t, e) {
  if (t === e)
    return !0;
  if (typeof t != typeof e)
    return !1;
  if (typeof t == "function" && t.toString() === e.toString())
    return !0;
  let n, o, r;
  if (t && e && typeof t == "object") {
    if (Array.isArray(t)) {
      if (n = t.length, n !== e.length) return !1;
      for (o = n; o-- !== 0; )
        if (!mt(t[o], e[o]))
          return !1;
      return !0;
    }
    if (r = Object.keys(t), n = r.length, n !== Object.keys(e).length)
      return !1;
    for (o = n; o-- !== 0; )
      if (!{}.hasOwnProperty.call(e, r[o]))
        return !1;
    for (o = n; o-- !== 0; ) {
      const i = r[o];
      if (!(i === "_owner" && t.$$typeof) && !mt(t[i], e[i]))
        return !1;
    }
    return !0;
  }
  return t !== t && e !== e;
}
function ue(t) {
  return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function Qt(t, e) {
  const n = ue(t);
  return Math.round(e * n) / n;
}
function Et(t) {
  const e = y.useRef(t);
  return ft(() => {
    e.current = t;
  }), e;
}
function Fn(t) {
  t === void 0 && (t = {});
  const {
    placement: e = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: r,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: c = !0,
    whileElementsMounted: a,
    open: l
  } = t, [f, u] = y.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [p, d] = y.useState(o);
  mt(p, o) || d(o);
  const [h, m] = y.useState(null), [w, g] = y.useState(null), v = y.useCallback((R) => {
    R !== P.current && (P.current = R, m(R));
  }, []), E = y.useCallback((R) => {
    R !== x.current && (x.current = R, g(R));
  }, []), b = i || h, A = s || w, P = y.useRef(null), x = y.useRef(null), O = y.useRef(f), M = a != null, C = Et(a), N = Et(r), F = Et(l), D = y.useCallback(() => {
    if (!P.current || !x.current)
      return;
    const R = {
      placement: e,
      strategy: n,
      middleware: p
    };
    N.current && (R.platform = N.current), Nn(P.current, x.current, R).then((k) => {
      const I = {
        ...k,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: F.current !== !1
      };
      S.current && !mt(O.current, I) && (O.current = I, Fe.flushSync(() => {
        u(I);
      }));
    });
  }, [p, e, n, N, F]);
  ft(() => {
    l === !1 && O.current.isPositioned && (O.current.isPositioned = !1, u((R) => ({
      ...R,
      isPositioned: !1
    })));
  }, [l]);
  const S = y.useRef(!1);
  ft(() => (S.current = !0, () => {
    S.current = !1;
  }), []), ft(() => {
    if (b && (P.current = b), A && (x.current = A), b && A) {
      if (C.current)
        return C.current(b, A, D);
      D();
    }
  }, [b, A, D, C, M]);
  const $ = y.useMemo(() => ({
    reference: P,
    floating: x,
    setReference: v,
    setFloating: E
  }), [v, E]), L = y.useMemo(() => ({
    reference: b,
    floating: A
  }), [b, A]), T = y.useMemo(() => {
    const R = {
      position: n,
      left: 0,
      top: 0
    };
    if (!L.floating)
      return R;
    const k = Qt(L.floating, f.x), I = Qt(L.floating, f.y);
    return c ? {
      ...R,
      transform: "translate(" + k + "px, " + I + "px)",
      ...ue(L.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: k,
      top: I
    };
  }, [n, c, L.floating, f.x, f.y]);
  return y.useMemo(() => ({
    ...f,
    update: D,
    refs: $,
    elements: L,
    floatingStyles: T
  }), [f, D, $, L, T]);
}
const Wn = (t) => {
  function e(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: t,
    fn(n) {
      const {
        element: o,
        padding: r
      } = typeof t == "function" ? t(n) : t;
      return o && e(o) ? o.current != null ? Jt({
        element: o.current,
        padding: r
      }).fn(n) : {} : o ? Jt({
        element: o,
        padding: r
      }).fn(n) : {};
    }
  };
}, Bn = (t, e) => ({
  ...Sn(t),
  options: [t, e]
}), $n = (t, e) => ({
  ...Dn(t),
  options: [t, e]
}), Hn = (t, e) => ({
  ...kn(t),
  options: [t, e]
}), _n = (t, e) => ({
  ...Ln(t),
  options: [t, e]
}), zn = (t, e) => ({
  ...Tn(t),
  options: [t, e]
}), In = (t, e) => ({
  ...Mn(t),
  options: [t, e]
}), Vn = (t, e) => ({
  ...Wn(t),
  options: [t, e]
});
var Yn = "Arrow", de = y.forwardRef((t, e) => {
  const { children: n, width: o = 10, height: r = 5, ...i } = t;
  return /* @__PURE__ */ H(
    tt.svg,
    {
      ...i,
      ref: e,
      width: o,
      height: r,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: t.asChild ? n : /* @__PURE__ */ H("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
de.displayName = Yn;
var jn = de;
function Xn(t) {
  const [e, n] = y.useState(void 0);
  return ut(() => {
    if (t) {
      n({ width: t.offsetWidth, height: t.offsetHeight });
      const o = new ResizeObserver((r) => {
        if (!Array.isArray(r) || !r.length)
          return;
        const i = r[0];
        let s, c;
        if ("borderBoxSize" in i) {
          const a = i.borderBoxSize, l = Array.isArray(a) ? a[0] : a;
          s = l.inlineSize, c = l.blockSize;
        } else
          s = t.offsetWidth, c = t.offsetHeight;
        n({ width: s, height: c });
      });
      return o.observe(t, { box: "border-box" }), () => o.unobserve(t);
    } else
      n(void 0);
  }, [t]), e;
}
var Ft = "Popper", [pe, co] = Ne(Ft), [Un, he] = pe(Ft), me = (t) => {
  const { __scopePopper: e, children: n } = t, [o, r] = y.useState(null);
  return /* @__PURE__ */ H(Un, { scope: e, anchor: o, onAnchorChange: r, children: n });
};
me.displayName = Ft;
var ge = "PopperAnchor", we = y.forwardRef(
  (t, e) => {
    const { __scopePopper: n, virtualRef: o, ...r } = t, i = he(ge, n), s = y.useRef(null), c = wt(e, s);
    return y.useEffect(() => {
      i.onAnchorChange((o == null ? void 0 : o.current) || s.current);
    }), o ? null : /* @__PURE__ */ H(tt.div, { ...r, ref: c });
  }
);
we.displayName = ge;
var Wt = "PopperContent", [qn, Kn] = pe(Wt), ye = y.forwardRef(
  (t, e) => {
    var Bt, $t, Ht, _t, zt, It;
    const {
      __scopePopper: n,
      side: o = "bottom",
      sideOffset: r = 0,
      align: i = "center",
      alignOffset: s = 0,
      arrowPadding: c = 0,
      avoidCollisions: a = !0,
      collisionBoundary: l = [],
      collisionPadding: f = 0,
      sticky: u = "partial",
      hideWhenDetached: p = !1,
      updatePositionStrategy: d = "optimized",
      onPlaced: h,
      ...m
    } = t, w = he(Wt, n), [g, v] = y.useState(null), E = wt(e, (ot) => v(ot)), [b, A] = y.useState(null), P = Xn(b), x = (P == null ? void 0 : P.width) ?? 0, O = (P == null ? void 0 : P.height) ?? 0, M = o + (i !== "center" ? "-" + i : ""), C = typeof f == "number" ? f : { top: 0, right: 0, bottom: 0, left: 0, ...f }, N = Array.isArray(l) ? l : [l], F = N.length > 0, D = {
      padding: C,
      boundary: N.filter(Gn),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: F
    }, { refs: S, floatingStyles: $, placement: L, isPositioned: T, middlewareData: R } = Fn({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: M,
      whileElementsMounted: (...ot) => Cn(...ot, {
        animationFrame: d === "always"
      }),
      elements: {
        reference: w.anchor
      },
      middleware: [
        Bn({ mainAxis: r + O, alignmentAxis: s }),
        a && $n({
          mainAxis: !0,
          crossAxis: !1,
          limiter: u === "partial" ? Hn() : void 0,
          ...D
        }),
        a && _n({ ...D }),
        zn({
          ...D,
          apply: ({ elements: ot, rects: Vt, availableWidth: Ce, availableHeight: Se }) => {
            const { width: De, height: Le } = Vt.reference, lt = ot.floating.style;
            lt.setProperty("--radix-popper-available-width", `${Ce}px`), lt.setProperty("--radix-popper-available-height", `${Se}px`), lt.setProperty("--radix-popper-anchor-width", `${De}px`), lt.setProperty("--radix-popper-anchor-height", `${Le}px`);
          }
        }),
        b && Vn({ element: b, padding: c }),
        Jn({ arrowWidth: x, arrowHeight: O }),
        p && In({ strategy: "referenceHidden", ...D })
      ]
    }), [k, I] = be(L), ct = gt(h);
    ut(() => {
      T && (ct == null || ct());
    }, [T, ct]);
    const Ae = (Bt = R.arrow) == null ? void 0 : Bt.x, Ee = ($t = R.arrow) == null ? void 0 : $t.y, Pe = ((Ht = R.arrow) == null ? void 0 : Ht.centerOffset) !== 0, [Re, Oe] = y.useState();
    return ut(() => {
      g && Oe(window.getComputedStyle(g).zIndex);
    }, [g]), /* @__PURE__ */ H(
      "div",
      {
        ref: S.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...$,
          transform: T ? $.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Re,
          "--radix-popper-transform-origin": [
            (_t = R.transformOrigin) == null ? void 0 : _t.x,
            (zt = R.transformOrigin) == null ? void 0 : zt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((It = R.hide) == null ? void 0 : It.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: t.dir,
        children: /* @__PURE__ */ H(
          qn,
          {
            scope: n,
            placedSide: k,
            onArrowChange: A,
            arrowX: Ae,
            arrowY: Ee,
            shouldHideArrow: Pe,
            children: /* @__PURE__ */ H(
              tt.div,
              {
                "data-side": k,
                "data-align": I,
                ...m,
                ref: E,
                style: {
                  ...m.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: T ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
ye.displayName = Wt;
var xe = "PopperArrow", Zn = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, ve = y.forwardRef(function(e, n) {
  const { __scopePopper: o, ...r } = e, i = Kn(xe, o), s = Zn[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ H(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ H(
          jn,
          {
            ...r,
            ref: n,
            style: {
              ...r.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
ve.displayName = xe;
function Gn(t) {
  return t !== null;
}
var Jn = (t) => ({
  name: "transformOrigin",
  options: t,
  fn(e) {
    var w, g, v;
    const { placement: n, rects: o, middlewareData: r } = e, s = ((w = r.arrow) == null ? void 0 : w.centerOffset) !== 0, c = s ? 0 : t.arrowWidth, a = s ? 0 : t.arrowHeight, [l, f] = be(n), u = { start: "0%", center: "50%", end: "100%" }[f], p = (((g = r.arrow) == null ? void 0 : g.x) ?? 0) + c / 2, d = (((v = r.arrow) == null ? void 0 : v.y) ?? 0) + a / 2;
    let h = "", m = "";
    return l === "bottom" ? (h = s ? u : `${p}px`, m = `${-a}px`) : l === "top" ? (h = s ? u : `${p}px`, m = `${o.floating.height + a}px`) : l === "right" ? (h = `${-a}px`, m = s ? u : `${d}px`) : l === "left" && (h = `${o.floating.width + a}px`, m = s ? u : `${d}px`), { data: { x: h, y: m } };
  }
});
function be(t) {
  const [e, n = "center"] = t.split("-");
  return [e, n];
}
var lo = me, ao = we, fo = ye, uo = ve, Qn = "Portal", to = y.forwardRef((t, e) => {
  var c;
  const { container: n, ...o } = t, [r, i] = y.useState(!1);
  ut(() => i(!0), []);
  const s = n || r && ((c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : c.body);
  return s ? We.createPortal(/* @__PURE__ */ H(tt.div, { ...o, ref: e }), s) : null;
});
to.displayName = Qn;
export {
  ao as A,
  fo as C,
  ze as D,
  to as P,
  lo as R,
  uo as a,
  co as c
};
