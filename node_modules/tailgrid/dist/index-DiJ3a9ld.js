import { jsx as y, Fragment as H } from "react/jsx-runtime";
import * as L from "react";
import { useId as A, useRef as E, useContext as I, useInsertionEffect as K, useCallback as N, useMemo as M, Children as O, isValidElement as S, useState as b } from "react";
import { M as U, u as T, P as V, a as X, b as _, L as B } from "./proxy-g3OKwrzk.js";
class F extends L.Component {
  getSnapshotBeforeUpdate(c) {
    const e = this.props.childRef.current;
    if (e && c.isPresent && !this.props.isPresent) {
      const s = e.offsetParent, f = s instanceof HTMLElement && s.offsetWidth || 0, t = this.props.sizeRef.current;
      t.height = e.offsetHeight || 0, t.width = e.offsetWidth || 0, t.top = e.offsetTop, t.left = e.offsetLeft, t.right = f - t.width - t.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function G({ children: r, isPresent: c, anchorX: e }) {
  const s = A(), f = E(null), t = E({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  }), { nonce: a } = I(U);
  return K(() => {
    const { width: C, height: o, top: m, left: n, right: h } = t.current;
    if (c || !f.current || !C || !o)
      return;
    const d = e === "left" ? `left: ${n}` : `right: ${h}`;
    f.current.dataset.motionPopId = s;
    const l = document.createElement("style");
    return a && (l.nonce = a), document.head.appendChild(l), l.sheet && l.sheet.insertRule(`
          [data-motion-pop-id="${s}"] {
            position: absolute !important;
            width: ${C}px !important;
            height: ${o}px !important;
            ${d}px !important;
            top: ${m}px !important;
          }
        `), () => {
      document.head.removeChild(l);
    };
  }, [c]), y(F, { isPresent: c, childRef: f, sizeRef: t, children: L.cloneElement(r, { ref: f }) });
}
const Y = ({ children: r, initial: c, isPresent: e, onExitComplete: s, custom: f, presenceAffectsLayout: t, mode: a, anchorX: C }) => {
  const o = T(q), m = A(), n = N((d) => {
    o.set(d, !0);
    for (const l of o.values())
      if (!l)
        return;
    s && s();
  }, [o, s]), h = M(
    () => ({
      id: m,
      initial: c,
      isPresent: e,
      custom: f,
      onExitComplete: n,
      register: (d) => (o.set(d, !1), () => o.delete(d))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    t ? [Math.random(), n] : [e, n]
  );
  return M(() => {
    o.forEach((d, l) => o.set(l, !1));
  }, [e]), L.useEffect(() => {
    !e && !o.size && s && s();
  }, [e]), a === "popLayout" && (r = y(G, { isPresent: e, anchorX: C, children: r })), y(V.Provider, { value: h, children: r });
};
function q() {
  return /* @__PURE__ */ new Map();
}
const w = (r) => r.key || "";
function k(r) {
  const c = [];
  return O.forEach(r, (e) => {
    S(e) && c.push(e);
  }), c;
}
const ee = ({ children: r, custom: c, initial: e = !0, onExitComplete: s, presenceAffectsLayout: f = !0, mode: t = "sync", propagate: a = !1, anchorX: C = "left" }) => {
  const [o, m] = X(a), n = M(() => k(r), [r]), h = a && !o ? [] : n.map(w), d = E(!0), l = E(n), g = T(() => /* @__PURE__ */ new Map()), [D, W] = b(n), [p, $] = b(n);
  _(() => {
    d.current = !1, l.current = n;
    for (let u = 0; u < p.length; u++) {
      const i = w(p[u]);
      h.includes(i) ? g.delete(i) : g.get(i) !== !0 && g.set(i, !1);
    }
  }, [p, h.length, h.join("-")]);
  const v = [];
  if (n !== D) {
    let u = [...n];
    for (let i = 0; i < p.length; i++) {
      const x = p[i], R = w(x);
      h.includes(R) || (u.splice(i, 0, x), v.push(x));
    }
    return t === "wait" && v.length && (u = v), $(k(u)), W(n), null;
  }
  process.env.NODE_ENV !== "production" && t === "wait" && p.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: P } = I(B);
  return y(H, { children: p.map((u) => {
    const i = w(u), x = a && !o ? !1 : n === p || h.includes(i), R = () => {
      if (g.has(i))
        g.set(i, !0);
      else
        return;
      let z = !0;
      g.forEach((j) => {
        j || (z = !1);
      }), z && (P == null || P(), $(l.current), a && (m == null || m()), s && s());
    };
    return y(Y, { isPresent: x, initial: !d.current || e ? void 0 : !1, custom: c, presenceAffectsLayout: f, mode: t, onExitComplete: x ? void 0 : R, anchorX: C, children: u }, i);
  }) });
};
export {
  ee as A
};
